name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend

jobs:
  # ===========================================
  # PHASE 1: CODE QUALITY & LINTING
  # ===========================================
  lint:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Python linting (using your existing backend)
      - name: Install Python linting tools
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black pylint
          pip install -r app/backend/requirements.txt

      - name: Lint Python code with flake8
        run: |
          # stop the build if there are Python syntax errors or undefined names
          flake8 app/backend --count --select=E9,F63,F7,F82 --show-source --statistics
          # exit-zero treats all errors as warnings
          flake8 app/backend --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Check Python code formatting with black
        run: |
          black --check app/backend

      - name: Lint with pylint
        run: |
          pylint app/backend --exit-zero

      # TODO: Add more comprehensive linting
      - name: "[PLACEHOLDER] Infrastructure as Code Linting"
        run: |
          echo "ðŸ” TODO: Add Dockerfile linting with hadolint"
          echo "ðŸ“ TODO: Add K8s manifest validation with kubeval"
          echo "ðŸ“ TODO: Add YAML linting"

  # ===========================================
  # PHASE 2: SECURITY SCANNING
  # ===========================================
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Basic security scanning with Trivy
      - name: Run Trivy vulnerability scanner (filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          exit-code: '0'  # Don't fail build on vulnerabilities yet

      # TODO: Add more comprehensive security scanning
      - name: "[PLACEHOLDER] Advanced Security Scanning"
        run: |
          echo "ðŸ”’ TODO: Add Python dependency scanning with safety"
          echo "ðŸ”’ TODO: Add secret detection with truffleHog"
          echo "ðŸ”’ TODO: Add SAST scanning with CodeQL"

  # ===========================================
  # PHASE 3: UNIT & COMPONENT TESTING
  # ===========================================
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # Run your existing backend tests
      - name: Install Python dependencies
        run: |
          cd app/backend
          pip install -r requirements.txt
          pip install pytest pytest-cov

      - name: Run Backend Unit Tests
        run: |
          cd app/backend
          python -m pytest test_app.py -v --cov=app --cov-report=xml

      # TODO: Add more comprehensive testing
      - name: "[PLACEHOLDER] Extended Testing Suite"
        run: |
          echo "ðŸ§ª TODO: Add frontend unit tests (if adding JS frameworks)"
          echo "ðŸ“Š TODO: Upload coverage to Codecov"
          echo "ðŸ§ª TODO: Add API contract testing"

  # ===========================================
  # PHASE 4: BUILD DOCKER IMAGES
  # ===========================================
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [lint, security, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Add a step to create lowercase repo name
      - name: Set lowercase repository name
        id: repo
        run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build backend image (using your existing Dockerfile.backend)
      - name: Build Backend Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile.backend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/backend:latest
            ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build frontend image (using your existing Dockerfile.frontend)
      - name: Build Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile.frontend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/frontend:latest
            ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Container security scanning
      - name: Scan Backend Image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/backend:${{ github.sha }}
          exit-code: '0'  # Don't fail build on vulnerabilities yet

      - name: Scan Frontend Image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/frontend:${{ github.sha }}
          exit-code: '0'  # Don't fail build on vulnerabilities yet
          
  # ===========================================
  # PHASE 5: INTEGRATION TESTING
  # ===========================================
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Add the same lowercase step as in build
      - name: Set lowercase repository name
        id: repo
        run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      # Test with your existing docker-compose.yml but using built images
      - name: Run Integration Tests with Docker Compose
        run: |
          # Create the monitoring directory and extract prometheus config
          mkdir -p monitoring
          
          # Extract just the prometheus.yml content from your k8s file
          cat > monitoring/prometheus-config.yaml << 'EOF'
          global:
            scrape_interval: 15s
            evaluation_interval: 15s

          scrape_configs:
            # Prometheus itself
            - job_name: 'prometheus'
              static_configs:
                - targets: ['localhost:9090']

            # Backend application metrics (for docker-compose)
            - job_name: 'backend-app'
              static_configs:
                - targets: ['backend:5000']
              metrics_path: '/metrics'
              scrape_interval: 10s
          EOF
          
          # Now proceed with your existing docker-compose modification
          cp docker/docker-compose.yml docker/docker-compose.test.yml
          
          # Update image references to use the built images from registry
          sed -i "s|build:|#build:|g" docker/docker-compose.test.yml
          sed -i "s|context: ..|#context: ..|g" docker/docker-compose.test.yml
          sed -i "s|dockerfile: docker/Dockerfile.backend|#dockerfile: docker/Dockerfile.backend|g" docker/docker-compose.test.yml
          sed -i "s|dockerfile: docker/Dockerfile.frontend|#dockerfile: docker/Dockerfile.frontend|g" docker/docker-compose.test.yml
          
          # Add image references - target specific services to avoid conflicts
          # Replace #build: in backend service context
          sed -i '/backend:/,/frontend:/ s|#build:|image: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/backend:${{ github.sha }}|' docker/docker-compose.test.yml
          
          # Replace #build: in frontend service context  
          sed -i '/frontend:/,$ s|#build:|image: ${{ env.REGISTRY }}/${{ steps.repo.outputs.name }}/frontend:${{ github.sha }}|' docker/docker-compose.test.yml
          
          # Debug: Show what the file looks like
          echo "ðŸ” Docker Compose file contents:"
          cat docker/docker-compose.test.yml
          
          # Start the full stack
          docker compose -f docker/docker-compose.test.yml up -d
          
          # Wait for services to be ready
          echo "â³ Waiting for services to start..."
          sleep 45
          
          # Show running containers for debugging
          echo "ðŸ“¦ Running containers:"
          docker ps
          
          # Show logs for debugging
          echo "ðŸ“ Container logs:"
          docker compose -f docker/docker-compose.test.yml logs
          
          # Run health checks - NOTE: Your backend runs on port 5000 internally, maps to 6000!
          echo "ðŸ¥ Running health checks..."
          curl -f http://localhost:6000/health || (echo "âŒ Backend health check failed" && exit 1)
          
          # Test API endpoints
          echo "ðŸ§ª Testing API endpoints..."
          curl -f http://localhost:6000/api/data || (echo "âŒ API endpoint test failed" && exit 1)
          
          # Test frontend (basic connectivity)
          curl -f http://localhost:80/ || echo "âš ï¸  Frontend check skipped (may not have health endpoint)"
          
          echo "âœ… All integration tests passed!"
          
          # Cleanup
          docker compose -f docker/docker-compose.test.yml down

      # TODO: Add more comprehensive integration testing
      - name: "[PLACEHOLDER] Advanced Integration Testing"
        run: |
          echo "ðŸ§ª TODO: Add end-to-end testing with Playwright/Cypress"
          echo "âš¡ TODO: Add load testing with k6"
          echo "ðŸ“Š TODO: Add performance benchmarks"

  # ===========================================
  # DEPLOYMENT SECTION (COMMENTED OUT)
  # Choose your deployment strategy below
  # ===========================================

  # OPTION 1: LOCAL/DEVELOPMENT DEPLOYMENT
  # Uncomment this section if you want to deploy to a local K8s cluster
  # deploy-local:
  #   name: Deploy to Local K8s
  #   runs-on: ubuntu-latest
  #   needs: [integration-test]
  #   if: github.ref == 'refs/heads/develop'
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #   
  #   - name: Update K8s manifests with new image tags
  #     run: |
  #       # Update your K8s deployments to use the new images
  #       sed -i 's|image: sre-learning-app-backend:latest|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:${{ github.sha }}|' k8s/deployment-backend.yaml
  #       sed -i 's|image: sre-learning-app-frontend:latest|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:${{ github.sha }}|' k8s/deployment-frontend.yaml
  #   
  #   - name: "[PLACEHOLDER] Deploy to Local K8s"
  #     run: |
  #       echo "ðŸš€ TODO: Configure kubectl connection to your local cluster"
  #       echo "ðŸ“¦ TODO: Apply K8s manifests: kubectl apply -f k8s/"
  #       echo "â³ TODO: Wait for rollout: kubectl rollout status deployment/backend-deployment"

  # OPTION 2: AWS EKS DEPLOYMENT
  # Uncomment and configure this section when you're ready for AWS
  # deploy-aws-staging:
  #   name: Deploy to AWS EKS (Staging)
  #   runs-on: ubuntu-latest
  #   needs: [integration-test]
  #   if: github.ref == 'refs/heads/main'
  #   environment: staging
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4
  #   
  #   - name: "[PLACEHOLDER] Configure AWS credentials"
  #     run: |
  #       echo "ðŸ”‘ TODO: Add AWS_ACCESS_KEY_ID to GitHub secrets"
  #       echo "ðŸ”‘ TODO: Add AWS_SECRET_ACCESS_KEY to GitHub secrets"
  #       echo "ðŸ”‘ TODO: Configure aws-actions/configure-aws-credentials@v4"
  #   
  #   - name: "[PLACEHOLDER] Configure kubectl for EKS"
  #     run: |
  #       echo "â˜¸ï¸  TODO: Create EKS cluster with Terraform (infra/aws/main.tf)"
  #       echo "âš™ï¸  TODO: aws eks update-kubeconfig --region us-west-2 --name your-cluster-name"
  #   
  #   - name: "[PLACEHOLDER] Deploy to EKS"
  #     run: |
  #       echo "ðŸ“¦ TODO: Apply K8s manifests to EKS"
  #       echo "ðŸ”„ TODO: Update image tags in K8s manifests"
  #       echo "â³ TODO: Wait for rollout completion"

  # OPTION 3: OTHER CLOUD PROVIDERS
  # deploy-gcp:
  #   name: Deploy to Google Cloud (GKE)
  #   # TODO: Configure GKE deployment
  #
  # deploy-azure:
  #   name: Deploy to Azure (AKS)
  #   # TODO: Configure AKS deployment

# ===========================================
# NEXT STEPS & RECOMMENDATIONS
# ===========================================
# 
# 1. ðŸŽ¯ IMMEDIATE FOCUS (Week 1-2):
#    - Get this basic CI/CD pipeline working
#    - Fix any linting/testing issues
#    - Ensure Docker builds work properly
#
# 2. ðŸ”§ ENHANCEMENT PHASE (Week 3-4):
#    - Add more comprehensive tests
#    - Implement proper security scanning
#    - Add performance testing
#
# 3. â˜ï¸  CLOUD DEPLOYMENT (Month 2):
#    - Decide: AWS EKS vs GCP GKE vs Azure AKS
#    - Set up Terraform infrastructure (infra/aws/main.tf)
#    - Configure cloud-specific deployment
#
# 4. ðŸš€ ADVANCED FEATURES (Month 3+):
#    - GitOps with ArgoCD/Flux
#    - Canary deployments
#    - Multi-environment promotion
#    - Monitoring & alerting integration
